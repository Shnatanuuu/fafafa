import streamlit as st
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas as rl_canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.cidfonts import UnicodeCIDFont
from datetime import datetime
import io
import pytz
from openai import OpenAI
import os
from dotenv import load_dotenv
import re

load_dotenv()

openai_api_key = os.getenv("OPENAI_API_KEY")
openai_client = OpenAI(api_key=openai_api_key) if openai_api_key else None

# â”€â”€â”€ Register Chinese font once â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try:
    pdfmetrics.registerFont(UnicodeCIDFont('STSong-Light'))
    CHINESE_FONT = 'STSong-Light'
except Exception:
    CHINESE_FONT = 'Helvetica'

# â”€â”€â”€ Page config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.set_page_config(
    page_title="Production Risk Assessment Report",
    page_icon="ğŸ“‹",
    layout="wide",
    initial_sidebar_state="expanded"
)

# â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CHINESE_CITIES = {
    "Guangzhou":"å¹¿å·","Shenzhen":"æ·±åœ³","Dongguan":"ä¸œè","Foshan":"ä½›å±±",
    "Zhongshan":"ä¸­å±±","Huizhou":"æƒ å·","Zhuhai":"ç æµ·","Jiangmen":"æ±Ÿé—¨",
    "Zhaoqing":"è‚‡åº†","Shanghai":"ä¸Šæµ·","Beijing":"åŒ—äº¬","Suzhou":"è‹å·",
    "Hangzhou":"æ­å·","Ningbo":"å®æ³¢","Wenzhou":"æ¸©å·","Wuhan":"æ­¦æ±‰",
    "Chengdu":"æˆéƒ½","Chongqing":"é‡åº†","Tianjin":"å¤©æ´¥","Nanjing":"å—äº¬",
    "Xi'an":"è¥¿å®‰","Qingdao":"é’å²›","Dalian":"å¤§è¿","Shenyang":"æ²ˆé˜³",
    "Changsha":"é•¿æ²™","Zhengzhou":"éƒ‘å·","Jinan":"æµå—","Harbin":"å“ˆå°”æ»¨",
    "Changchun":"é•¿æ˜¥","Taiyuan":"å¤ªåŸ","Shijiazhuang":"çŸ³å®¶åº„","Lanzhou":"å…°å·",
    "Xiamen":"å¦é—¨","Fuzhou":"ç¦å·","Nanning":"å—å®","Kunming":"æ˜†æ˜",
    "Guiyang":"è´µé˜³","Haikou":"æµ·å£","ÃœrÃ¼mqi":"ä¹Œé²æœ¨é½","Lhasa":"æ‹‰è¨",
}

# Risk stages definition
RISK_STAGES = [
    {
        "key":    "style",
        "en":     "1. Style & Construction Risk",
        "zh":     "1. æ¬¾å¼ä¸ç»“æ„é£é™©",
        "sub_en": "Potential production risk generated by styling features on this product",
        "sub_zh": "äº§å“æ¬¾å¼ç‰¹å¾æ‰€äº§ç”Ÿçš„æ½œåœ¨ç”Ÿäº§é£é™©",
    },
    {
        "key":    "material",
        "en":     "2. Raw Material Risk",
        "zh":     "2. åŸææ–™é£é™©",
        "sub_en": "Potential risk presented to manufacture by properties of the material",
        "sub_zh": "ææ–™ç‰¹æ€§å¯¹ç”Ÿäº§é€ æˆçš„æ½œåœ¨é£é™©",
    },
    {
        "key":    "factory",
        "en":     "3. Factory Performance Risk",
        "zh":     "3. å·¥å‚ç”Ÿäº§é£é™©",
        "sub_en": "Factory production potential risks (including finishing etc.)",
        "sub_zh": "å·¥å‚ç”Ÿäº§æ½œåœ¨é£é™©ï¼ˆå«åæ•´ç­‰ï¼‰",
    },
    {
        "key":    "package",
        "en":     "4. Package Risk",
        "zh":     "4. åŒ…è£…é£é™©",
        "sub_en": "Packaging related risks",
        "sub_zh": "åŒ…è£…ç›¸å…³é£é™©",
    },
    {
        "key":    "other",
        "en":     "5. Other Risks",
        "zh":     "5. å…¶ä»–é£é™©",
        "sub_en": "Any other potential risks",
        "sub_zh": "å…¶ä»–æ½œåœ¨é£é™©",
    },
]

# â”€â”€â”€ UI text lookup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UI_TEXTS = {
    "en": {
        "title":             "Production Risk Assessment Report",
        "basic_info":        "Basic Information",
        "risk_assessment":   "Risk Assessment",
        "dept_comments":     "Department Comments",
        "conclusion":        "Conclusion",
        "signatures":        "Signatures & Approvals",
        "generate_pdf":      "ğŸ¯ Generate PDF Report",
        "download_pdf":      "ğŸ“¥ Download PDF Report",
        "po_number":         "PO / Order Number",
        "factory":           "Factory Name",
        "style":             "Style / Model",
        "brand":             "Brand / Trademark",
        "sales":             "Sales / Business",
        "assessment_date":   "Assessment Date",
        "description":       "Description (Sales, Tech & QC write)",
        "cap_desc":          "CAP Description (Corrective Action Plan)",
        "sales_comments":    "Sales Comments",
        "tech_comments":     "Technical Comments",
        "qc_comments":       "QC Manager Comments",
        "conclusion_text":   "Overall Conclusion",
        "qc_signature":      "QC Manager Signature",
        "qc_date":           "QC Date",
        "select_location":   "Select Assessment Location",
        "ui_lang":           "User Interface Language",
        "pdf_lang":          "PDF Report Language",
        "local_time":        "Local Time",
        "translation_active":"Translation API: Active",
        "translation_off":   "Translation API: Not Configured",
        "cities":            "Cities",
        "languages":         "Languages",
        "api_setup":         "API Setup",
        "tab_basic":         "ğŸ“‹ Basic Info",
        "tab_risk":          "ğŸ” Risk Assessment",
        "tab_sign":          "âœï¸ Signatures",
        "fill_required":     "Please fill in at least PO Number and Factory Name!",
        "creating_pdf":      "Creating your professional PDF report...",
        "generate_success":  "PDF Generated Successfully!",
        "pdf_details":       "PDF Details",
        "report_language":   "Report Language",
        "generated":         "Generated",
        "location":          "Location",
        "error_generating":  "Error generating PDF",
        "footer_text":       "Production Risk Assessment System",
        "powered_by":        "Powered by Streamlit",
        "copyright":         "Â© 2025 - Production Risk Assessment Platform",
        "instructions_title":"Quick Guide",
        "instructions":      "1. Fill all required fields\n2. Complete risk assessments\n3. Add department comments\n4. Select preferred languages\n5. Generate PDF report",
        "process_flow":      "Report Workflow",
        "process_steps":     "1. Sales opens form\n2. Discuss with Technical dept\n3. Send to factory\n4. QC follows up\n5. Final report distribution",
    },
    "zh": {
        "title":             "ç”Ÿäº§é£é™©è¯„ä¼°æŠ¥å‘Š",
        "basic_info":        "åŸºæœ¬ä¿¡æ¯",
        "risk_assessment":   "é£é™©è¯„ä¼°",
        "dept_comments":     "éƒ¨é—¨æ„è§",
        "conclusion":        "ç»“è®º",
        "signatures":        "ç­¾ç½²ä¸æ‰¹å‡†",
        "generate_pdf":      "ğŸ¯ ç”ŸæˆPDFæŠ¥å‘Š",
        "download_pdf":      "ğŸ“¥ ä¸‹è½½PDFæŠ¥å‘Š",
        "po_number":         "PO / è®¢å•ç¼–å·",
        "factory":           "å·¥å‚åç§°",
        "style":             "æ¬¾å¼ / å‹å·",
        "brand":             "å“ç‰Œ / å•†æ ‡",
        "sales":             "é”€å”® / ä¸šåŠ¡",
        "assessment_date":   "è¯„ä¼°æ—¥æœŸ",
        "description":       "æè¿°ï¼ˆé”€å”®ã€æŠ€æœ¯åŠå“æ§ç»ç†å¡«å†™ï¼‰",
        "cap_desc":          "çº æ­£æªæ–½è®¡åˆ’ï¼ˆCAPï¼‰æè¿°",
        "sales_comments":    "é”€å”®æ„è§",
        "tech_comments":     "æŠ€æœ¯éƒ¨æ„è§",
        "qc_comments":       "å“æ§ç»ç†æ„è§",
        "conclusion_text":   "æ€»ä½“ç»“è®º",
        "qc_signature":      "å“æ§ç»ç†ç­¾å",
        "qc_date":           "å“æ§æ—¥æœŸ",
        "select_location":   "é€‰æ‹©è¯„ä¼°åœ°ç‚¹",
        "ui_lang":           "ç•Œé¢è¯­è¨€",
        "pdf_lang":          "PDFæŠ¥å‘Šè¯­è¨€",
        "local_time":        "æœ¬åœ°æ—¶é—´",
        "translation_active":"ç¿»è¯‘API: å·²å¯ç”¨",
        "translation_off":   "ç¿»è¯‘API: æœªé…ç½®",
        "cities":            "åŸå¸‚",
        "languages":         "è¯­è¨€",
        "api_setup":         "APIè®¾ç½®",
        "tab_basic":         "ğŸ“‹ åŸºæœ¬ä¿¡æ¯",
        "tab_risk":          "ğŸ” é£é™©è¯„ä¼°",
        "tab_sign":          "âœï¸ ç­¾ç½²",
        "fill_required":     "è¯·è‡³å°‘å¡«å†™POç¼–å·å’Œå·¥å‚åç§°ï¼",
        "creating_pdf":      "æ­£åœ¨åˆ›å»ºä¸“ä¸šPDFæŠ¥å‘Š...",
        "generate_success":  "PDFç”ŸæˆæˆåŠŸï¼",
        "pdf_details":       "PDFè¯¦æƒ…",
        "report_language":   "æŠ¥å‘Šè¯­è¨€",
        "generated":         "ç”Ÿæˆæ—¶é—´",
        "location":          "åœ°ç‚¹",
        "error_generating":  "ç”ŸæˆPDFå‡ºé”™",
        "footer_text":       "ç”Ÿäº§é£é™©è¯„ä¼°ç³»ç»Ÿ",
        "powered_by":        "ç”± Streamlit æä¾›æ”¯æŒ",
        "copyright":         "Â© 2025 - ç”Ÿäº§é£é™©è¯„ä¼°å¹³å°",
        "instructions_title":"å¿«é€ŸæŒ‡å—",
        "instructions":      "1. å¡«å†™æ‰€æœ‰å¿…å¡«å­—æ®µ\n2. å®Œæˆé£é™©è¯„ä¼°\n3. æ·»åŠ éƒ¨é—¨æ„è§\n4. é€‰æ‹©åå¥½è¯­è¨€\n5. ç”ŸæˆPDFæŠ¥å‘Š",
        "process_flow":      "æŠ¥å‘Šæµç¨‹",
        "process_steps":     "1. é”€å”®å¼€å¯è¡¨å•\n2. ä¸æŠ€æœ¯éƒ¨è®¨è®º\n3. å‘é€è‡³å·¥å‚\n4. å“æ§è·Ÿè¿›\n5. æœ€ç»ˆæŠ¥å‘Šåˆ†å‘",
    },
}

def t(key):
    lang = st.session_state.get('ui_language', 'en')
    return UI_TEXTS[lang].get(key, UI_TEXTS['en'].get(key, key))

def translate_text_api(text, target_language="zh"):
    """Translate free-form user text via GPT-4o-mini with caching."""
    if not text or not text.strip():
        return text
    if not openai_client:
        return text
    cache_key = f"{text}|{target_language}"
    if cache_key in st.session_state.translations_cache:
        return st.session_state.translations_cache[cache_key]
    clean = text.replace(' ', '').replace('-', '').replace('/', '')
    if clean.isdigit() or re.match(r'^[A-Za-z]*\d+[A-Za-z]*$', clean):
        st.session_state.translations_cache[cache_key] = text
        return text
    if re.search(r'[\u4e00-\u9fff]', text):
        st.session_state.translations_cache[cache_key] = text
        return text
    try:
        lang_name = "Simplified Chinese" if target_language == "zh" else "English"
        resp = openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": f"Translate to {lang_name}. Preserve numbers, codes, measurements. Return ONLY the translation."},
                {"role": "user", "content": text}
            ],
            temperature=0.1, max_tokens=500
        )
        result = resp.choices[0].message.content.strip()
        st.session_state.translations_cache[cache_key] = result
        return result
    except Exception:
        st.session_state.translations_cache[cache_key] = text
        return text

# â”€â”€â”€ Session state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for key, val in [
    ('ui_language',         'en'),
    ('pdf_language',        'en'),
    ('selected_city',       'Shanghai'),
    ('translations_cache',  {}),
]:
    if key not in st.session_state:
        st.session_state[key] = val

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  PDF DESIGN TOKENS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
C_PRIMARY   = colors.HexColor('#1a1a2e')
C_ACCENT    = colors.HexColor('#e94560')
C_ACCENT2   = colors.HexColor('#0f3460')
C_LIGHT     = colors.HexColor('#f0f4ff')
C_WHITE     = colors.white
C_GREY_TEXT = colors.HexColor('#555555')
C_GREY_LINE = colors.HexColor('#dddddd')
C_GREEN     = colors.HexColor('#27ae60')
C_RED       = colors.HexColor('#e74c3c')
C_ORANGE    = colors.HexColor('#f39c12')

PAGE_W, PAGE_H = A4
HEADER_H  = 60
FOOTER_H  = 36
MARGIN_L  = 40
MARGIN_R  = 40
CONTENT_W = PAGE_W - MARGIN_L - MARGIN_R


def _font(pdf_lang, bold=False):
    if pdf_lang == "zh":
        return CHINESE_FONT
    return 'Helvetica-Bold' if bold else 'Helvetica'


# â”€â”€â”€ Text width measurement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _char_width(ch, font_size):
    """
    Return approximate rendered width of a single character in points.
    Chinese/CJK characters are full-width (~1.0x font_size).
    ASCII characters are ~0.52x font_size.
    """
    cp = ord(ch)
    # CJK Unified Ideographs, CJK Extension, CJK Symbols & Punctuation,
    # Fullwidth Forms, Katakana, Hiragana, etc.
    if (0x4E00 <= cp <= 0x9FFF or   # CJK Unified Ideographs
        0x3400 <= cp <= 0x4DBF or   # CJK Extension A
        0x20000 <= cp <= 0x2A6DF or # CJK Extension B
        0x3000 <= cp <= 0x303F or   # CJK Symbols and Punctuation
        0xFF00 <= cp <= 0xFFEF or   # Halfwidth and Fullwidth Forms
        0x3040 <= cp <= 0x309F or   # Hiragana
        0x30A0 <= cp <= 0x30FF):    # Katakana
        return font_size * 1.0
    return font_size * 0.52


def _text_width(text, font_size):
    """Return approximate rendered pixel width of a text string."""
    return sum(_char_width(ch, font_size) for ch in text)


def _wrap_text(text, max_width, font_size):
    """
    Wrap text to fit within max_width (in points), correctly handling
    CJK characters (full-width) vs ASCII (half-width).
    Returns a list of line strings.
    """
    if not text or not text.strip():
        return ["â€”"]

    lines = []
    # Split on existing newlines first
    paragraphs = text.replace('\r\n', '\n').replace('\r', '\n').split('\n')

    for paragraph in paragraphs:
        if not paragraph.strip():
            lines.append("")
            continue

        words = paragraph.split()
        current = ""
        current_w = 0.0

        for word in words:
            word_w = _text_width(word, font_size)
            space_w = _text_width(" ", font_size)

            if current == "":
                # First word on line â€” if single word wider than max, break it by char
                if word_w > max_width:
                    # Break long word character by character
                    for ch in word:
                        ch_w = _char_width(ch, font_size)
                        if current_w + ch_w > max_width and current:
                            lines.append(current)
                            current = ch
                            current_w = ch_w
                        else:
                            current += ch
                            current_w += ch_w
                else:
                    current = word
                    current_w = word_w
            else:
                test_w = current_w + space_w + word_w
                if test_w <= max_width:
                    current += " " + word
                    current_w = test_w
                else:
                    lines.append(current)
                    if word_w > max_width:
                        # Break long word character by character
                        current = ""
                        current_w = 0.0
                        for ch in word:
                            ch_w = _char_width(ch, font_size)
                            if current_w + ch_w > max_width and current:
                                lines.append(current)
                                current = ch
                                current_w = ch_w
                            else:
                                current += ch
                                current_w += ch_w
                    else:
                        current = word
                        current_w = word_w

        if current:
            lines.append(current)

    return lines if lines else ["â€”"]


# â”€â”€â”€ Shared drawing primitives â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def draw_page_frame(c, page_num, total_pages, pdf_lang, city, city_zh, gen_time):
    w, h = PAGE_W, PAGE_H
    # Header
    c.setFillColor(C_PRIMARY)
    c.rect(0, h - HEADER_H, w, HEADER_H, fill=1, stroke=0)
    c.setFillColor(C_ACCENT)
    c.rect(0, h - HEADER_H, 6, HEADER_H, fill=1, stroke=0)

    fn = _font(pdf_lang, bold=True)
    header_l = "Grand Step (H.K.) Ltd"
    header_r = "ç”Ÿäº§é£é™©è¯„ä¼°æŠ¥å‘Š" if pdf_lang == "zh" else "PRODUCTION RISK ASSESSMENT REPORT"
    c.setFillColor(C_WHITE)
    c.setFont(fn, 13)
    c.drawString(MARGIN_L, h - HEADER_H + 22, header_l)
    c.setFont(_font(pdf_lang), 9)
    c.drawRightString(w - MARGIN_R, h - HEADER_H + 22, header_r)

    # Footer
    c.setFillColor(C_PRIMARY)
    c.rect(0, 0, w, FOOTER_H, fill=1, stroke=0)
    c.setFillColor(C_ACCENT)
    c.rect(0, FOOTER_H - 3, w, 3, fill=1, stroke=0)
    c.setFillColor(C_WHITE)
    c.setFont(_font(pdf_lang), 7.5)

    loc_str  = f"åœ°ç‚¹: {city} ({city_zh})"  if pdf_lang == "zh" else f"Location: {city}"
    pg_str   = f"ç¬¬ {page_num} é¡µ / å…± {total_pages} é¡µ" if pdf_lang == "zh" else f"Page {page_num} of {total_pages}"
    time_str = f"ç”Ÿæˆæ—¶é—´: {gen_time}" if pdf_lang == "zh" else f"Generated: {gen_time}"

    c.drawString(MARGIN_L, 13, loc_str)
    c.drawCentredString(w / 2, 13, time_str)
    c.drawRightString(w - MARGIN_R, 13, pg_str)


def draw_section_header(c, y, label, pdf_lang):
    bar_h = 22
    c.setFillColor(C_ACCENT2)
    c.roundRect(MARGIN_L, y - bar_h, CONTENT_W, bar_h, 4, fill=1, stroke=0)
    c.setFillColor(C_WHITE)
    c.setFont(_font(pdf_lang, bold=True), 10)
    c.drawString(MARGIN_L + 10, y - bar_h + 7, label)
    return y - bar_h - 8


def draw_kv_row(c, x, y, w, label, value, pdf_lang, shade=False):
    ROW_H = 18
    if shade:
        c.setFillColor(C_LIGHT)
        c.rect(x, y - ROW_H, w, ROW_H, fill=1, stroke=0)
    c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.4)
    c.line(x, y - ROW_H, x + w, y - ROW_H)
    lw = w * 0.38
    c.setFillColor(C_ACCENT2); c.setFont(_font(pdf_lang, bold=True), 8)
    c.drawString(x + 6, y - ROW_H + 6, label)
    c.setFillColor(C_PRIMARY); c.setFont(_font(pdf_lang), 8)
    c.drawString(x + lw + 6, y - ROW_H + 6, str(value)[:80])
    return y - ROW_H


def draw_two_col_kv(c, y, pairs, pdf_lang, shade_alt=True):
    col_w = (CONTENT_W - 10) / 2
    for i, (l1, v1, l2, v2) in enumerate(pairs):
        shade = (i % 2 == 0) and shade_alt
        draw_kv_row(c, MARGIN_L,              y, col_w, l1, v1, pdf_lang, shade)
        draw_kv_row(c, MARGIN_L + col_w + 10, y, col_w, l2, v2, pdf_lang, shade)
        y -= 18
    return y


def draw_text_block(c, y, label, text, pdf_lang, accent_color=None):
    """
    Full-width multi-line text block. Dynamically sizes to content.
    Correctly handles CJK (full-width) vs ASCII (half-width) characters.
    Returns new y.
    """
    if not text or not text.strip():
        text = "â€”"
    if accent_color is None:
        accent_color = C_ACCENT2

    fn_b      = _font(pdf_lang, bold=True)
    fn_r      = _font(pdf_lang)
    FONT_SIZE = 8
    LINE_H    = 14
    PADDING   = 8
    LABEL_H   = 18

    # Use pixel-aware wrapping
    max_text_width = CONTENT_W - 20  # 10px padding each side
    lines = _wrap_text(text, max_text_width, FONT_SIZE)

    total_text_h = len(lines) * LINE_H + PADDING * 2
    block_h      = LABEL_H + total_text_h

    # Background
    c.setFillColor(C_LIGHT)
    c.rect(MARGIN_L, y - block_h, CONTENT_W, block_h, fill=1, stroke=0)
    # Label bar
    c.setFillColor(accent_color)
    c.rect(MARGIN_L, y - LABEL_H, CONTENT_W, LABEL_H, fill=1, stroke=0)
    # Border
    c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.4)
    c.rect(MARGIN_L, y - block_h, CONTENT_W, block_h, fill=0, stroke=1)

    # Label text
    c.setFillColor(C_WHITE); c.setFont(fn_b, 8)
    c.drawString(MARGIN_L + 8, y - LABEL_H + 6, label)

    # Content text
    ty = y - LABEL_H - PADDING - LINE_H + 4
    c.setFillColor(C_PRIMARY); c.setFont(fn_r, FONT_SIZE)
    for line in lines:
        if line:  # skip blank separator lines
            c.drawString(MARGIN_L + 10, ty, line)
        ty -= LINE_H

    return y - block_h - 6


def draw_risk_table(c, y, rows, col_labels, pdf_lang):
    """
    Three-column risk table: Risk Stage | Description | CAP Description
    rows: list of (stage_label, desc_text, cap_text)
    Uses pixel-aware text wrapping for correct CJK layout.
    """
    COL_WIDTHS = [CONTENT_W * 0.28, CONTENT_W * 0.36, CONTENT_W * 0.36]
    HDR_H   = 22
    ROW_PAD = 8
    FONT_SIZE = 8
    LINE_H    = 13

    # Inner text width per column (minus padding)
    col_inner = [cw - 12 for cw in COL_WIDTHS]

    fn_b = _font(pdf_lang, bold=True)
    fn_r = _font(pdf_lang)

    # â”€â”€ Header â”€â”€
    c.setFillColor(C_ACCENT)
    c.rect(MARGIN_L, y - HDR_H, CONTENT_W, HDR_H, fill=1, stroke=0)
    c.setFillColor(C_WHITE); c.setFont(fn_b, 8.5)
    cx = MARGIN_L + 6
    for i, lbl in enumerate(col_labels):
        c.drawString(cx, y - HDR_H + 8, lbl)
        cx += COL_WIDTHS[i]
    y -= HDR_H

    # Track where the table started for outer border
    table_top = y

    for i, (stage, desc, cap) in enumerate(rows):
        # Wrap each column using pixel-accurate wrapping
        stage_lines = _wrap_text(stage, col_inner[0], FONT_SIZE)
        desc_lines  = _wrap_text(desc,  col_inner[1], FONT_SIZE)
        cap_lines   = _wrap_text(cap,   col_inner[2], FONT_SIZE)

        max_lines = max(len(stage_lines), len(desc_lines), len(cap_lines))
        row_h     = max_lines * LINE_H + ROW_PAD * 2

        # Row background
        shade = (i % 2 == 0)
        if shade:
            c.setFillColor(C_LIGHT)
            c.rect(MARGIN_L, y - row_h, CONTENT_W, row_h, fill=1, stroke=0)

        # Bottom separator
        c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.3)
        c.line(MARGIN_L, y - row_h, MARGIN_L + CONTENT_W, y - row_h)

        # Vertical column separators
        cx_sep = MARGIN_L + COL_WIDTHS[0]
        c.line(cx_sep, y, cx_sep, y - row_h)
        cx_sep += COL_WIDTHS[1]
        c.line(cx_sep, y, cx_sep, y - row_h)

        # Stage column (bold, accent colour)
        c.setFillColor(C_ACCENT2); c.setFont(fn_b, FONT_SIZE)
        ty = y - ROW_PAD - LINE_H + 3
        for ln in stage_lines:
            if ln:
                c.drawString(MARGIN_L + 6, ty, ln)
            ty -= LINE_H

        # Description column
        c.setFillColor(C_PRIMARY); c.setFont(fn_r, FONT_SIZE)
        ty = y - ROW_PAD - LINE_H + 3
        for ln in desc_lines:
            if ln:
                c.drawString(MARGIN_L + COL_WIDTHS[0] + 6, ty, ln)
            ty -= LINE_H

        # CAP column
        ty = y - ROW_PAD - LINE_H + 3
        for ln in cap_lines:
            if ln:
                c.drawString(MARGIN_L + COL_WIDTHS[0] + COL_WIDTHS[1] + 6, ty, ln)
            ty -= LINE_H

        y -= row_h

    # Outer border around the entire table body
    table_body_h = table_top - y
    c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.5)
    c.rect(MARGIN_L, y, CONTENT_W, table_body_h, fill=0, stroke=1)

    return y - 6


def draw_score_bar(c, x, y, score, max_score=5, bar_w=80, bar_h=8):
    c.setFillColor(C_GREY_LINE)
    c.roundRect(x, y, bar_w, bar_h, 3, fill=1, stroke=0)
    fill_w = bar_w * (score / max_score)
    col = C_GREEN if score >= 4 else (C_ORANGE if score >= 3 else C_RED)
    c.setFillColor(col)
    c.roundRect(x, y, fill_w, bar_h, 3, fill=1, stroke=0)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  PDF GENERATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generate_pdf():
    pdf_lang = st.session_state.pdf_language
    city     = st.session_state.selected_city
    city_zh  = CHINESE_CITIES.get(city, city)
    china_tz = pytz.timezone('Asia/Shanghai')
    now      = datetime.now(china_tz)
    gen_time = now.strftime('%Y-%m-%d %H:%M')
    gen_date = now.strftime('%Y-%m-%d')

    def tx(text):
        if pdf_lang == "en" or not openai_client:
            return text or ''
        return translate_text_api(text or '', "zh")

    def loc(en_val, zh_val):
        return zh_val if pdf_lang == "zh" else en_val

    # â”€â”€ Pull form data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    po_number   = st.session_state.get('po_number',   '')
    style_val   = st.session_state.get('style_val',   '')
    brand       = st.session_state.get('brand',       '')
    sales       = st.session_state.get('sales',       '')
    factory     = st.session_state.get('factory',     '')
    adate       = st.session_state.get('assessment_date', now.date())
    adate_str   = str(adate)

    sales_comments = st.session_state.get('sales_comments', '')
    tech_comments  = st.session_state.get('tech_comments',  '')
    qc_comments    = st.session_state.get('qc_comments',    '')
    conclusion     = st.session_state.get('conclusion_text','')
    qc_sig         = st.session_state.get('qc_signature',   '')
    qc_date        = st.session_state.get('qc_date',        now.date())
    qc_date_str    = str(qc_date)

    # Risk stage data
    risk_rows = []
    for stage in RISK_STAGES:
        k   = stage["key"]
        lbl = stage["zh"] if pdf_lang == "zh" else stage["en"]
        desc = tx(st.session_state.get(f"{k}_desc", ''))
        cap  = tx(st.session_state.get(f"{k}_cap",  ''))
        risk_rows.append((lbl, desc, cap))

    # â”€â”€ Two-pass for correct page total â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _build(buf_out, total_pages_known):
        c = rl_canvas.Canvas(buf_out, pagesize=A4)
        fn_b = _font(pdf_lang, bold=True)
        fn_r = _font(pdf_lang)

        page_counter = [1]

        def new_page():
            c.showPage()
            page_counter[0] += 1
            draw_page_frame(c, page_counter[0], total_pages_known,
                            pdf_lang, city, city_zh, gen_time)
            return PAGE_H - HEADER_H - 20

        def maybe_new_page(y, min_space=120):
            if y < FOOTER_H + min_space:
                return new_page()
            return y

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PAGE 1 â€” Cover + Basic Information
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        draw_page_frame(c, 1, total_pages_known, pdf_lang, city, city_zh, gen_time)
        y = PAGE_H - HEADER_H - 20

        # Cover banner
        c.setFillColor(C_PRIMARY)
        c.rect(MARGIN_L, y - 120, CONTENT_W, 120, fill=1, stroke=0)
        c.setFillColor(C_ACCENT)
        c.rect(MARGIN_L, y - 120, 8, 120, fill=1, stroke=0)
        c.setFillColor(C_ACCENT)
        c.rect(MARGIN_L, y - 6, CONTENT_W, 6, fill=1, stroke=0)

        c.setFillColor(C_WHITE); c.setFont(fn_b, 20)
        c.drawString(MARGIN_L + 24, y - 40, "Grand Step (H.K.) Ltd")
        c.setFont(fn_r, 11)
        c.setFillColor(colors.HexColor('#aab8ff'))
        c.drawString(MARGIN_L + 24, y - 60,
                     "ç”Ÿäº§é£é™©è¯„ä¼°æŠ¥å‘Š" if pdf_lang == "zh" else "PRODUCTION RISK ASSESSMENT REPORT")

        pill_items = [
            (loc("Date","æ—¥æœŸ"),     gen_date),
            (loc("Location","åœ°ç‚¹"), f"{city} {city_zh}" if pdf_lang == "zh" else city),
            (loc("Language","è¯­è¨€"), "ä¸­æ–‡" if pdf_lang == "zh" else "English"),
        ]
        px = MARGIN_L + 24
        for lbl, val in pill_items:
            c.setFillColor(colors.HexColor('#0d2244'))
            pill_w = _text_width(f"{lbl}: {val}", 7) + 16
            c.roundRect(px, y - 108, pill_w, 16, 4, fill=1, stroke=0)
            c.setFillColor(colors.HexColor('#aab8ff')); c.setFont(fn_b, 7)
            c.drawString(px + 8, y - 100, f"{lbl}:")
            lbl_w = _text_width(lbl, 7) + 8
            c.setFillColor(C_WHITE); c.setFont(fn_r, 7)
            c.drawString(px + 8 + lbl_w, y - 100, val)
            px += pill_w + 8
        y -= 136

        # Basic Information
        y = draw_section_header(c, y, loc("1. BASIC INFORMATION","1. åŸºæœ¬ä¿¡æ¯"), pdf_lang)

        pairs = [
            (loc("PO / Order Number","PO / è®¢å•ç¼–å·"), po_number or 'â€”',
             loc("Brand / Trademark","å“ç‰Œ / å•†æ ‡"),   tx(brand)  or 'â€”'),
            (loc("Style / Model","æ¬¾å¼ / å‹å·"),        tx(style_val) or 'â€”',
             loc("Sales / Business","é”€å”® / ä¸šåŠ¡"),     tx(sales)  or 'â€”'),
            (loc("Factory Name","å·¥å‚åç§°"),            tx(factory) or 'â€”',
             loc("Assessment Date","è¯„ä¼°æ—¥æœŸ"),         adate_str),
        ]
        y = draw_two_col_kv(c, y, pairs, pdf_lang)
        y -= 10

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Risk Assessment Table
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        y = maybe_new_page(y, 200)
        y = draw_section_header(c, y, loc("2. RISK ASSESSMENT MATRIX","2. é£é™©è¯„ä¼°çŸ©é˜µ"), pdf_lang)

        col_labels = [
            loc("Risk Stage","é£é™©é˜¶æ®µ"),
            loc("Description","æè¿°"),
            loc("CAP Description","çº æ­£æªæ–½"),
        ]

        # Check if the table will overflow one page and handle across pages
        # For simplicity: render row by row, starting a new page if needed
        COL_WIDTHS = [CONTENT_W * 0.28, CONTENT_W * 0.36, CONTENT_W * 0.36]
        HDR_H   = 22
        ROW_PAD = 8
        FONT_SIZE_TBL = 8
        LINE_H_TBL    = 13
        col_inner = [cw - 12 for cw in COL_WIDTHS]

        # Draw table header
        def draw_table_header(cy):
            c.setFillColor(C_ACCENT)
            c.rect(MARGIN_L, cy - HDR_H, CONTENT_W, HDR_H, fill=1, stroke=0)
            c.setFillColor(C_WHITE); c.setFont(_font(pdf_lang, bold=True), 8.5)
            cx2 = MARGIN_L + 6
            for ii, lbl in enumerate(col_labels):
                c.drawString(cx2, cy - HDR_H + 8, lbl)
                cx2 += COL_WIDTHS[ii]
            return cy - HDR_H

        y = draw_table_header(y)
        table_top = y

        for row_idx, (stage, desc, cap) in enumerate(risk_rows):
            stage_lines = _wrap_text(stage, col_inner[0], FONT_SIZE_TBL)
            desc_lines  = _wrap_text(desc,  col_inner[1], FONT_SIZE_TBL)
            cap_lines   = _wrap_text(cap,   col_inner[2], FONT_SIZE_TBL)

            max_lines = max(len(stage_lines), len(desc_lines), len(cap_lines))
            row_h     = max_lines * LINE_H_TBL + ROW_PAD * 2

            # If row doesn't fit on current page, close table border, new page, redraw header
            if y - row_h < FOOTER_H + 20:
                # Close current table border
                table_body_h = table_top - y
                if table_body_h > 0:
                    c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.5)
                    c.rect(MARGIN_L, y, CONTENT_W, table_body_h, fill=0, stroke=1)
                y = new_page()
                y = draw_table_header(y)
                table_top = y

            shade = (row_idx % 2 == 0)
            if shade:
                c.setFillColor(C_LIGHT)
                c.rect(MARGIN_L, y - row_h, CONTENT_W, row_h, fill=1, stroke=0)

            c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.3)
            c.line(MARGIN_L, y - row_h, MARGIN_L + CONTENT_W, y - row_h)

            cx_sep = MARGIN_L + COL_WIDTHS[0]
            c.line(cx_sep, y, cx_sep, y - row_h)
            cx_sep += COL_WIDTHS[1]
            c.line(cx_sep, y, cx_sep, y - row_h)

            c.setFillColor(C_ACCENT2); c.setFont(_font(pdf_lang, bold=True), FONT_SIZE_TBL)
            ty = y - ROW_PAD - LINE_H_TBL + 3
            for ln in stage_lines:
                if ln:
                    c.drawString(MARGIN_L + 6, ty, ln)
                ty -= LINE_H_TBL

            c.setFillColor(C_PRIMARY); c.setFont(_font(pdf_lang), FONT_SIZE_TBL)
            ty = y - ROW_PAD - LINE_H_TBL + 3
            for ln in desc_lines:
                if ln:
                    c.drawString(MARGIN_L + COL_WIDTHS[0] + 6, ty, ln)
                ty -= LINE_H_TBL

            ty = y - ROW_PAD - LINE_H_TBL + 3
            for ln in cap_lines:
                if ln:
                    c.drawString(MARGIN_L + COL_WIDTHS[0] + COL_WIDTHS[1] + 6, ty, ln)
                ty -= LINE_H_TBL

            y -= row_h

        # Close final table border
        table_body_h = table_top - y
        if table_body_h > 0:
            c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.5)
            c.rect(MARGIN_L, y, CONTENT_W, table_body_h, fill=0, stroke=1)
        y -= 6

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Department Comments page
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        y = new_page()
        y = draw_section_header(c, y, loc("3. DEPARTMENT COMMENTS","3. éƒ¨é—¨æ„è§"), pdf_lang)

        y = draw_text_block(c, y, loc("Sales Comments:","é”€å”®æ„è§ï¼š"),
                            tx(sales_comments), pdf_lang, C_ACCENT2)
        y = maybe_new_page(y, 80)
        y = draw_text_block(c, y, loc("Technical Comments:","æŠ€æœ¯éƒ¨æ„è§ï¼š"),
                            tx(tech_comments), pdf_lang, C_ACCENT2)
        y = maybe_new_page(y, 80)
        y = draw_text_block(c, y, loc("QC Manager Comments:","å“æ§ç»ç†æ„è§ï¼š"),
                            tx(qc_comments), pdf_lang, C_ACCENT2)
        y -= 10

        # Conclusion
        y = maybe_new_page(y, 120)
        y = draw_section_header(c, y, loc("4. CONCLUSION & APPROVALS","4. ç»“è®ºä¸æ‰¹å‡†"), pdf_lang)
        y = draw_text_block(c, y, loc("Overall Conclusion:","æ€»ä½“ç»“è®ºï¼š"),
                            tx(conclusion), pdf_lang, C_ACCENT)
        y -= 16

        # Signature row
        y = maybe_new_page(y, 100)
        c.setFillColor(C_LIGHT)
        c.roundRect(MARGIN_L, y - 54, CONTENT_W, 54, 4, fill=1, stroke=0)
        c.setStrokeColor(C_GREY_LINE); c.setLineWidth(0.5)
        c.roundRect(MARGIN_L, y - 54, CONTENT_W, 54, 4, fill=0, stroke=1)

        c.setFillColor(C_ACCENT2); c.setFont(fn_b, 8)
        c.drawString(MARGIN_L + 10, y - 18, loc("QC Manager:","å“æ§ç»ç†ï¼š"))
        c.setFillColor(C_PRIMARY); c.setFont(fn_r, 8)
        c.drawString(MARGIN_L + 10, y - 32, qc_sig or "_________________")

        c.setFillColor(C_ACCENT2); c.setFont(fn_b, 8)
        half = CONTENT_W / 2
        c.drawString(MARGIN_L + half + 10, y - 18, loc("Date:","æ—¥æœŸï¼š"))
        c.setFillColor(C_PRIMARY); c.setFont(fn_r, 8)
        c.drawString(MARGIN_L + half + 10, y - 32, qc_date_str)

        c.setStrokeColor(C_PRIMARY); c.setLineWidth(1)
        c.line(MARGIN_L + 10, y - 44, MARGIN_L + half - 10, y - 44)
        c.line(MARGIN_L + half + 10, y - 44, MARGIN_L + CONTENT_W - 10, y - 44)

        y -= 70

        # Process note
        y = maybe_new_page(y, 60)
        note = loc(
            "Note: QC will send this report to office together with final inspection report. "
            "Office assistant will upload to ERP system and send email to factory/agent accordingly.",
            "æ³¨ï¼šå“æ§å°†æ­¤æŠ¥å‘Šè¿åŒæœ€ç»ˆæ£€éªŒæŠ¥å‘Šä¸€å¹¶å‘é€è‡³åŠå…¬å®¤ã€‚"
            "åŠå…¬å®¤åŠ©ç†å°†ä¸Šä¼ è‡³ERPç³»ç»Ÿå¹¶ç›¸åº”å‘é€é‚®ä»¶è‡³å·¥å‚/ä»£ç†å•†ã€‚"
        )
        note_lines = _wrap_text(note, CONTENT_W - 20, 7.5)
        c.setFillColor(C_GREY_TEXT); c.setFont(fn_r, 7.5)
        for ln in note_lines:
            if ln:
                c.drawString(MARGIN_L, y, ln)
            y -= 11
        y -= 6

        # Confidentiality
        conf = loc(
            "This report is confidential property of Grand Step (H.K.) Ltd. Unauthorised distribution is prohibited.",
            "æœ¬æŠ¥å‘Šä¸ºGrand Step (H.K.) Ltdæœºå¯†æ–‡ä»¶ï¼Œæœªç»æˆæƒç¦æ­¢åˆ†å‘ã€‚"
        )
        c.setFillColor(C_GREY_TEXT); c.setFont(fn_r, 7.5)
        c.drawCentredString(PAGE_W / 2, FOOTER_H + 12, conf)

        c.save()
        return page_counter[0]

    # Pass 1: count pages
    count_buf = io.BytesIO()
    actual_total = _build(count_buf, 99)

    # Pass 2: real render
    buf = io.BytesIO()
    _build(buf, actual_total)
    buf.seek(0)
    return buf


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#  STREAMLIT UI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

st.markdown("""
<style>
  .main-header{font-size:2.6rem;font-weight:800;text-align:center;
  color: #4299E1;
  margin-bottom:1.5rem;padding:0.5rem;}
  .section-header{font-size:1.4rem;font-weight:700;color:#1a1a2e;
    margin:2rem 0 1rem;padding:0.7rem 1.2rem;
    background:linear-gradient(135deg,#f0f4ff 0%,#dde4ff 100%);
    border-radius:10px;border-left:5px solid #e94560;}
  .stButton>button{background:linear-gradient(135deg,#1a1a2e 0%,#e94560 100%);
    color:white;font-size:1.1rem;font-weight:600;padding:0.9rem 2rem;
    border-radius:10px;border:none;width:100%;transition:all .3s;}
  .stButton>button:hover{transform:translateY(-2px);box-shadow:0 8px 16px rgba(233,69,96,.35);}
  .footer{text-align:center;padding:1.5rem;
    background:linear-gradient(135deg,#f0f4ff 0%,#dde4ff 100%);
    border-radius:12px;margin-top:2rem;border-top:3px solid #e94560;}
  .location-badge{display:inline-flex;align-items:center;gap:6px;
    background:linear-gradient(135deg,#1a1a2e 0%,#0f3460 100%);
    color:white;padding:.4rem .9rem;border-radius:20px;font-weight:600;font-size:.85rem;}
  .risk-sub{font-size:.85rem;color:#555;font-style:italic;margin-bottom:.5rem;}
</style>
""", unsafe_allow_html=True)

# â”€â”€ Sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with st.sidebar:
    st.markdown("### âš™ï¸ Settings")

    st.markdown(f"#### ğŸŒ {t('ui_lang')}")
    ui_lang_choice = st.selectbox(
        t('ui_lang'),
        ["English", "ä¸­æ–‡ (Mandarin)"],
        index=0 if st.session_state.ui_language == "en" else 1,
        key="ui_lang_select", label_visibility="collapsed"
    )
    new_ui = "en" if ui_lang_choice == "English" else "zh"
    if new_ui != st.session_state.ui_language:
        st.session_state.ui_language = new_ui
        st.session_state.translations_cache = {}
        st.rerun()

    st.markdown(f"#### ğŸ“„ {t('pdf_lang')}")
    pdf_lang_choice = st.selectbox(
        t('pdf_lang'),
        ["English", "ä¸­æ–‡ (Mandarin)"],
        index=0 if st.session_state.pdf_language == "en" else 1,
        key="pdf_lang_select", label_visibility="collapsed"
    )
    st.session_state.pdf_language = "en" if pdf_lang_choice == "English" else "zh"

    st.markdown(f"#### ğŸ“ {t('select_location')}")
    city_keys = list(CHINESE_CITIES.keys())
    city_idx  = city_keys.index(st.session_state.selected_city) if st.session_state.selected_city in city_keys else 0
    sel_city  = st.selectbox(
        t('select_location'), city_keys, index=city_idx,
        key="city_select", label_visibility="collapsed"
    )
    st.session_state.selected_city = sel_city
    st.markdown(f'<div class="location-badge">ğŸ“ {sel_city} ({CHINESE_CITIES.get(sel_city,"")})</div>', unsafe_allow_html=True)

    st.markdown(f"#### ğŸ• {t('local_time')}")
    china_tz = pytz.timezone('Asia/Shanghai')
    now_cn   = datetime.now(china_tz)
    st.metric(t('local_time'), now_cn.strftime('%H:%M:%S'), now_cn.strftime('%Y-%m-%d'))

    if openai_client:
        st.success(f"âœ… {t('translation_active')}")
    else:
        st.warning(f"âš ï¸ {t('translation_off')}")

    st.markdown("---")
    col1, col2 = st.columns(2)
    with col1: st.metric(t('cities'), len(CHINESE_CITIES))
    with col2: st.metric(t('languages'), 2)

    st.markdown("---")
    st.markdown(f"### ğŸ”„ {t('process_flow')}")
    for line in t('process_steps').split('\n'):
        st.write(line)

    st.markdown("---")
    st.markdown(f"### â„¹ï¸ {t('instructions_title')}")
    for line in t('instructions').split('\n'):
        st.write(line)

    with st.expander(f"ğŸ”‘ {t('api_setup')}"):
        st.code("# Create .env file\nOPENAI_API_KEY=your-api-key-here")
        st.info("Restart after adding key to enable translation.")

# â”€â”€ Main header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.markdown(f'<div class="main-header">ğŸ“‹ {t("title")}</div>', unsafe_allow_html=True)

tab1, tab2, tab3 = st.tabs([t('tab_basic'), t('tab_risk'), t('tab_sign')])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
with tab1:
    st.markdown(f'<div class="section-header">ğŸ“‹ {t("basic_info")}</div>', unsafe_allow_html=True)
    c1, c2 = st.columns(2)
    with c1:
        st.text_input(f"ğŸ“„ {t('po_number')}", placeholder="PO-2024-001",                 key="po_number")
        st.text_input(f"ğŸ‘• {t('style')}",     placeholder="Model XYZ-2024",              key="style_val")
        st.text_input(f"ğŸ­ {t('factory')}",   placeholder="ABC Manufacturing Co., Ltd.", key="factory")
    with c2:
        st.text_input(f"ğŸ·ï¸ {t('brand')}",     placeholder="Brand Name",                  key="brand")
        st.text_input(f"ğŸ‘” {t('sales')}",     placeholder="Sales Representative Name",   key="sales")
        st.date_input(f"ğŸ• {t('assessment_date')}", datetime.now().date(),               key="assessment_date")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
with tab2:
    st.markdown(f'<div class="section-header">ğŸ” {t("risk_assessment")}</div>', unsafe_allow_html=True)

    for stage in RISK_STAGES:
        k    = stage["key"]
        lang = st.session_state.ui_language
        lbl  = stage["zh"] if lang == "zh" else stage["en"]
        sub  = stage["sub_zh"] if lang == "zh" else stage["sub_en"]

        st.markdown(f'<div class="section-header">ğŸ” {lbl}</div>', unsafe_allow_html=True)
        st.markdown(f'<p class="risk-sub">{sub}</p>', unsafe_allow_html=True)

        st.text_area(
            f"ğŸ“„ {t('description')}",
            placeholder=f"Describe {stage['en'].lower()}...",
            height=120,
            key=f"{k}_desc"
        )
        st.text_area(
            f"ğŸ”„ {t('cap_desc')}",
            placeholder="Describe corrective action plan...",
            height=100,
            key=f"{k}_cap"
        )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
with tab3:
    st.markdown(f'<div class="section-header">âœï¸ {t("dept_comments")}</div>', unsafe_allow_html=True)

    st.markdown(f"#### ğŸ‘” {t('sales_comments')}")
    st.text_area(t('sales_comments'), placeholder="Enter sales department comments here...",
                 height=120, key="sales_comments", label_visibility="collapsed")

    st.markdown(f"#### ğŸ”§ {t('tech_comments')}")
    st.text_area(t('tech_comments'), placeholder="Enter technical department comments here...",
                 height=120, key="tech_comments", label_visibility="collapsed")

    st.markdown(f"#### ğŸ‘ï¸ {t('qc_comments')}")
    st.text_area(t('qc_comments'), placeholder="Enter QC Manager comments here...",
                 height=120, key="qc_comments", label_visibility="collapsed")

    st.markdown(f'<div class="section-header">âœ… {t("conclusion")}</div>', unsafe_allow_html=True)
    st.text_area(t('conclusion_text'), placeholder="Enter overall conclusion and summary here...",
                 height=120, key="conclusion_text")

    st.markdown(f'<div class="section-header">âœï¸ {t("signatures")}</div>', unsafe_allow_html=True)
    c1, c2 = st.columns(2)
    with c1:
        st.text_input(f"ğŸ‘ï¸ {t('qc_signature')}", placeholder="QC Manager name", key="qc_signature")
    with c2:
        st.date_input(f"ğŸ“… {t('qc_date')}", datetime.now().date(), key="qc_date")

# â”€â”€ Generate button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.markdown("---")
_, center_col, _ = st.columns([1, 2, 1])
with center_col:
    if st.button(t('generate_pdf'), use_container_width=True):
        if not st.session_state.get('po_number') or not st.session_state.get('factory'):
            st.error(f"âš ï¸ {t('fill_required')}")
        else:
            with st.spinner(f"â³ {t('creating_pdf')}"):
                try:
                    pdf_buf = generate_pdf()
                    st.success(f"âœ… {t('generate_success')}")
                    with st.expander(f"â„¹ï¸ {t('pdf_details')}"):
                        mc1, mc2 = st.columns(2)
                        with mc1:
                            st.metric(t('location'),
                                      f"{st.session_state.selected_city} ({CHINESE_CITIES.get(st.session_state.selected_city,'')})")
                            st.metric(t('report_language'),
                                      "ä¸­æ–‡" if st.session_state.pdf_language == "zh" else "English")
                        with mc2:
                            st.metric(t('generated'),
                                      datetime.now(pytz.timezone('Asia/Shanghai')).strftime('%H:%M:%S'))
                    fname = (f"Risk_Assessment_{st.session_state.get('po_number','report')}_"
                             f"{st.session_state.selected_city}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf")
                    st.download_button(
                        label=t('download_pdf'),
                        data=pdf_buf, file_name=fname, mime="application/pdf",
                        use_container_width=True
                    )
                except Exception as e:
                    st.error(f"âŒ {t('error_generating')}: {str(e)}")
                    with st.expander("Debug"):
                        import traceback; st.code(traceback.format_exc())

# â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.markdown(f"""
<div class="footer">
  <p style="font-size:1.1rem;font-weight:700;color:#1a1a2e;margin-bottom:.4rem;">
    ğŸ“‹ {t('footer_text')}
  </p>
  <p style="font-size:.85rem;color:#555;">
    ğŸ“ {st.session_state.selected_city} ({CHINESE_CITIES.get(st.session_state.selected_city,'')}) &nbsp;|&nbsp;
    ğŸŒ {("ä¸­æ–‡" if st.session_state.pdf_language=="zh" else "English")}
  </p>
  <p style="font-size:.75rem;color:#999;margin-top:.8rem;">
    {t('powered_by')} &nbsp;|&nbsp; {t('copyright')}
  </p>
</div>
""", unsafe_allow_html=True)
